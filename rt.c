#include <stdio.h>
#include <stdlib.h>

void *calloc(size_t nmemb, size_t size);
void exit(int status);

/* generated by myy.scm */

int heap[] = {2, 2, 118, 2, 30, 2, 6, 2, 28, 2, 131638, 36, 14, 2, 6, 2, 60, 2, 131638, 68, 52, 76, 131126, 84, 22, 2, 6, 100, 108, 2, 262710, 116, 393262, 124, 46, 132, 6, 2, 22, 2, 6, 2, 14, 164, 6, 2, 38, 2, 180, 188, 134710, 196, 172, 204, 264758, 212, 156, 220, 133686, 228, 148, 236, 133174, 244, 94, 252, 94, 260, 140, 268, 22, 276, 92, 284, 22, 292, 44, 300, 22, 308, 20, 316, 22, 324, 12, 332, 22, 340, 38, 2, 356, 2, 2, 364, 2, 372, 380, 2, 348, 388, 3};

#define CELLS 10000
#define allocp(val) (0==(((int)val)&2))
#define immediatep(val) (2==(((int)val)&2))
#define imm(type,payload) (2 | (type << 3) | (payload << 8))
#define fixval(n) (((int) n) >> 3)
#define fixnum(n) ((((int) n) << 3) | 6)
#define fixnump(n) ((((int) n) & 7) == 6)
#define MNULL imm(0, 0)
#define MTRUE imm(1, 1)
#define MFALSE imm(1, 0)
#define aof(inst) ((inst >> 6) & 255)
#define bof(inst) (inst >> 14)
#define car(ptr) *((int *) (((int) ptr) & ~4))
#define cdr(ptr) *((int *) (4 | ((int) ptr)))
#define cons(a, b) (pair((int) a, (int) b)|4)

int S, E, C, D, T;
int *start, *fp, *end;

int pair(int a, int b) {
   int *this = fp;
   if ((int)fp == MNULL) {
      printf("GC time\n");
      exit(1);
   }
   fp += 2;
   this[0] = a;
   this[1] = b;
   return (int) this;
}

int lref(int lst, int pos) {
   while(pos--)
      lst = cdr(lst);
   return car(lst);
}

void list_args(int old, int ptr) {
   if (ptr == MNULL) {
      S = MNULL;
   } else {
      list_args(old, cdr(ptr));
      S = cons(lref(old, fixval(car(ptr))), S);
   }
}

int run() {
   while (C != MNULL) {
      int inst = fixval(car(C));
      printf("OP %d\n", (inst & 63));
      C = cdr(C);
      switch(inst&63) {
         case 11: /* op-load-value */
            printf("load-value if fixnum %d\n", fixval(car(C)));
            S = cons(car(C), S);
            C = cdr(C);
            break;
         case 12: /* op-equal */
            printf("comparing poss %d and %d -> %s\n", aof(inst), bof(inst), ((lref(S, aof(inst)) == lref(S, bof(inst))) ? "true" : "false"));
            S = cons(((lref(S, aof(inst)) == lref(S, bof(inst))) ? MTRUE : MFALSE), S);
            break;
         case 13: { /* op-if */
            C = ((lref(S, aof(inst)) == MFALSE) ? cdr(C) : car(C));
            break; }
         case 3: 
            S = cons(lref(S, aof(inst)), S);
            break;
         case 5: 
            S = cons(lref(lref(E, aof(inst)), bof(inst)), S);
            break;
         case 4: { /* op-return */
            int rval, st;
            secd_return:
            rval = car(S);
            st = car(D);
            D = cdr(D);
            S = car(st); st = cdr(st);
            E = car(st); st = cdr(st);
            C = car(st);
            S = cons(rval, S);
            if ((int) D == MNULL) {
               if (fixnump(car(S))) {
                  printf("VM HALT fixnum %d\n", fixval(car(S)));
               } else {
                  printf("VM HALT %d\n", car(S));
               }
               return fixval(car(S));
            }
            break; }
         case 2: { /* close */
            T = cons(S, E);
            T = pair(car(C), T); 
            C = cdr(C);
            S = cons(T, S);
            break; }
         case 6: { /* call */
            printf("calling offset %d\n", aof(inst));
            T = cons(cdr(C), MNULL);
            T = cons(E, T);
            T = cons(S, T);
            D = cons(T, D);
            T = lref(S, aof(inst)); /* operator */
            list_args(S, car(C)); /* construct to S*/
            E = cdr(T);
            C = car(T);
            break; }
         case 14: { /* add */
            int a = fixval(lref(S, aof(inst)));
            int b = fixval(lref(S, bof(inst)));
            S = cons(fixnum(a + b), S);
            break; }
         default:
            printf("vm: what inst is %d\n", inst&63);
            return 1;
      }
   }
   goto secd_return;
}

void load_heap() {
   int pos = 0;
   int *hp = start;
   int val;
   while (1) {
      int val = heap[pos];
      if (val == 3) { break; }
      *hp = (immediatep(val) ? val : ((int) start) + val);
      hp++;
      pos++;     
   }
   fp = hp;
   while(fp < end) { /* first sweep */
      cdr(fp) = ((int)fp)+8;
      fp++;
      fp++;
   }
   fp -= 2;
   cdr(fp) = MNULL;
   hp -= 2; /* last loaded is (C . E) */
   S = MNULL;
   E = MNULL;
   C = hp[0];
   D = hp[1];
}

int main(int nargs, char **args) {
   start  = (int *) calloc((sizeof (int *)), 2 * CELLS);
   end = ((int *) start) + 2*CELLS;
   load_heap();   
   return run();
}
