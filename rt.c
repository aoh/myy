#include <stdio.h>
#include <stdlib.h>

void *calloc(size_t nmemb, size_t size);
void exit(int status);

/* generated by myy.scm */

int heap[] = {2, 2, 638, 2, 14, 12, 94, 20, 1566, 2, 38, 2, 6, 2, 38, 52, 60, 2, 264246, 68, 44, 76, 131126, 84, 46, 92, 36, 100, 110, 108, 1126, 116, 14, 124, 94, 132, 6, 2, 14, 148, 156, 2, 262710, 164, 7206, 172, 94, 180, 46, 188, 38, 2, 630, 204, 132214, 212, 263798, 220, 2, 228, 1590, 236, 2, 244, 1078, 252, 2, 260, 566, 268, 2, 276, 54, 284, 196, 292, 22, 300, 140, 308, 22, 316, 28, 324, 22, 332, 38, 2, 348, 2, 2, 356, 2, 364, 372, 2, 340, 380, 3};

#define CELLS 10000
#define allocp(val) (0==(((int)val)&2))
#define immediatep(val) (2==(((int)val)&2))
#define imm(type,payload) (2 | (type << 3) | (payload << 8))
#define fixval(n) (((int) n) >> 3)
#define fixnum(n) ((((int) n) << 3) | 6)
#define fixnump(n) ((((int) n) & 7) == 6)
#define MNULL imm(0, 0)
#define MTRUE imm(1, 1)
#define MFALSE imm(1, 0)
#define aof(inst) ((inst >> 6) & 255)
#define bof(inst) (inst >> 14)
#define car(ptr) *((int *) (((int) ptr) & ~4))
#define cdr(ptr) *((int *) (4 | ((int) ptr)))
#define cons(a, b) (pair((int) a, (int) b)|4)

#define setmark(ptr) (ptr | 1)
#define unmark(ptr) (ptr ^ 1)
#define markp(ptr) (ptr & 1)

int S, E, C, D, T;
int *start, *fp, *end;
int gcs;

void mark(int this) {
   int foo;
   int parent = MNULL;
   printf("GC: marking %d\n", this);
   process: 
      printf(" - process %d\n", this);
      if(immediatep(this)) goto backtrack;
      foo = car(this);
      if (markp(foo)) goto backtrack;
      car(this) = setmark(parent);
      parent = (this|2);
      this = foo;
      goto process;
   backtrack:   
      printf(" - backtrack %d -> %d\n", this, parent);
      if (parent == MNULL)
         return;
      if (parent & 2) {
         parent = parent^2;
         foo = cdr(parent);
         cdr(parent) = unmark(car(parent));
         car(parent) = setmark(this);
         this = foo;
         goto process;
      }
      foo = cdr(parent);
      cdr(parent) = this;
      this = parent;
      parent = foo;
      goto backtrack;
}

int sweep() {
   int *pos = end - 2;
   fp = (int *) MNULL;
   int nfree = 0;
   while(start < pos) {
      int val = *pos;
      if (markp(val)) {
         *pos = unmark(val);
      } else {
         pos[1] = (int) fp;
         fp = pos;
         nfree++;
      }
      pos -= 2;
   }
   return nfree;
}

void gc(int a, int b) {
   int n;
   gcs++;
   //printf("GC: "); fflush(stdout);
   mark(S); mark(E); mark(C); mark(D); 
   mark(T); mark(a); mark(b);
   //printf("sweep ");
   n = sweep();
   //printf("free len %d\n", n);
   if (n < 100) {
      printf("Heap is too full\n");
      exit(1);
   }
}

int pair(int a, int b) {
   int *this;
   if ((int)fp == MNULL)
      gc(a, b);
   this = fp;
   fp = (int) cdr(fp);
   this[0] = a;
   this[1] = b;
   return (int) this;
}

int lref(int lst, int pos) {
   while(pos--)
      lst = cdr(lst);
   return car(lst);
}

int llen(int ptr) {
   int n = 0;
   while(ptr != MNULL) {
      n++;
      ptr = cdr(ptr);
   }
   return n;
}

void list_args(int old, int ptr) {
   if (ptr == MNULL) {
      S = MNULL;
   } else {
      list_args(old, cdr(ptr));
      S = cons(lref(old, fixval(car(ptr))), S);
   }
}

int run() {
   while (C != MNULL) {
      int inst = fixval(car(C));
      printf("FL %d\n", llen(fp));
      printf("OP %d\n", (inst & 63));
      C = cdr(C);
      switch(inst&63) {
         case 11: /* op-load-value */
            printf("load-value if fixnum %d\n", fixval(car(C)));
            S = cons(car(C), S);
            C = cdr(C);
            break;
         case 12: /* op-equal */
            printf("comparing poss %d and %d -> %s\n", aof(inst), bof(inst), ((lref(S, aof(inst)) == lref(S, bof(inst))) ? "true" : "false"));
            S = cons(((lref(S, aof(inst)) == lref(S, bof(inst))) ? MTRUE : MFALSE), S);
            break;
         case 13: { /* op-if */
            C = ((lref(S, aof(inst)) == MFALSE) ? cdr(C) : car(C));
            break; }
         case 3: 
            S = cons(lref(S, aof(inst)), S);
            break;
         case 5: 
            S = cons(lref(lref(E, aof(inst)), bof(inst)), S);
            break;
         case 4: { /* op-return */
            int rval, st;
            secd_return:
            rval = car(S);
            st = car(D);
            D = cdr(D);
            S = car(st); st = cdr(st);
            E = car(st); st = cdr(st);
            C = car(st);
            S = cons(rval, S);
            if ((int) D == MNULL) {
               if (fixnump(car(S))) {
                  printf("VM HALT fixnum %d after %d gcs\n", fixval(car(S)), gcs);
               } else {
                  printf("VM HALT %d\n", car(S));
               }
               return fixval(car(S));
            }
            break; }
         case 2: { /* close */
            T = cons(S, E);
            T = pair(car(C), T); 
            C = cdr(C);
            S = cons(T, S);
            break; }
         case 6: { /* call */
            printf("calling offset %d\n", aof(inst));
            T = cons(cdr(C), MNULL);
            T = cons(E, T);
            T = cons(S, T);
            D = cons(T, D);
            T = lref(S, aof(inst)); /* operator */
            list_args(S, car(C)); /* construct to S*/
            E = cdr(T);
            C = car(T);
            break; }
         case 14: { /* add */
            int a = fixval(lref(S, aof(inst)));
            int b = fixval(lref(S, bof(inst)));
            S = cons(fixnum(a + b), S);
            break; }
         case 15: { /* sub */
            int a = fixval(lref(S, aof(inst)));
            int b = fixval(lref(S, bof(inst)));
            S = cons(fixnum(a - b), S);
            break; }
         default:
            printf("vm: what inst is %d\n", inst&63);
            return 1;
      }
   }
   goto secd_return;
}

void load_heap() {
   int pos = 0;
   int *hp = start;
   int val;
   while (1) {
      int val = heap[pos];
      if (val == 3) { break; }
      *hp = (immediatep(val) ? val : ((int) start) + val);
      hp++;
      pos++;     
   }
   hp -= 2;
   S = MNULL;
   E = MNULL;
   C = hp[0];
   D = hp[1];
   T = MNULL;
   fp = hp;
   while(hp < end) { /* first sweep */
      cdr(hp) = ((int)hp)+8;
      hp += 2;
   }
   hp -= 2;
   cdr(hp) = MNULL;
   printf("BOOT null list length is %d\n", llen(MNULL));
   printf("BOOT free list length is %d\n", llen(fp));
}

int main(int nargs, char **args) {
   gcs = 0;
   start  = (int *) calloc((sizeof (int *)), 2 * CELLS);
   end = start + 2*CELLS;
   load_heap();   
   return run();
}
